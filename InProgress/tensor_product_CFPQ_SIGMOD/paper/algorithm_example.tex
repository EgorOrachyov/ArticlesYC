\subsection{An example}
\label{example:section}
In this section we introduce a detailed example to demonstrate the steps taken by the proposed algorithms.
Namely, consider the graph $\mathcal{G}$ presented in Figure~\ref{fig:example_input_graph} and the RSM $R$ presented in Figure~\ref{example:automata}.

At the first step we represent graph and RSM as a set of Boolean matrices.
Notice that we should formally add new empty matrix $M_2^{S}$ to $\mathcal{M}_2$,
where edges labeled by $S$ will be added at the time of the computation.

After the initialization, the algorithm handles the $\varepsilon$-case.
The input RSM does not have any $\varepsilon$-transitions and does not have states
that are both start and final, therefore, no edges added at this stage.
After that we should iteratively compute $\mathcal{M}_2$ and $C_3$.
We denote the iteration number of the loop of matrices evaluation as the number in parentheses in the subscript.

\textbf{First iteration.} First of all, we compute the Kronecker product of the
$\mathcal{M}_1$ and $\mathcal{M}_{2,(0)}$ matrices and store result in the
$\mathcal{M}_{3,(1)}$, and collapse this matrix to the single Boolean matrix
$M'_{3,(1)}$. For the sake of simplicity, we provide only
$M'_{3,(1)}$, which is evaluated as follows.
{
    \renewcommand{\arraystretch}{0.5}
    \setlength\arraycolsep{0.1pt}
\begin{align*}
  \centering
& M'_{3,(1)} = M_1^a \otimes M_{2,(0)}^a +  M_1^b \otimes M_{2,(0)}^b + M_1^S \otimes M_{2,(0)}^S =\\
& \kbordermatrix{
          & (0,0) & (0,1) & \vrule & (1,0) & (1,1) & \vrule &  (2,0) & (2,1) & \vrule &  (3,0) & (3,1) &\\
    (0,0) & . & .  & \vrule & . & 1  & \vrule & . & .  &  \vrule & . & .  \\
    (0,1) & . & .  & \vrule & 1 & .   & \vrule & . & .  &  \vrule & . & .  \\
    \hline
    (1,0) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . & . \\
    (1,1) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & .  &1   \\
    \hline
    (2,0) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . & .  \\
    (2,1) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . &1  \\
    \hline
    (3,0) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . & .  \\
    (3,1) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . & .  \\
}
\end{align*}
}
\begin{figure}[h]
    \centering
   \begin{tikzpicture}[->,auto,node distance=0.5cm]
       \node[state] (q_0)                      {$(0, 0)$};
       \node[state] (q_1) [right=of q_0] {$(1, 0)$};
       \node[state] (q_2)  [right=of q_1] {$(2, 0)$};
       \node[state] (q_3) [right=of q_2] {$(3, 0)$};
       \node[state] (q_4)  [below=of q_0] {$(0, 1)$};
       \node[state] (q_5)  [right=of q_4] {$(1, 1)$};
      \node[state] (q_6)  [right=of q_5] {$(2, 1)$};
       \node[state] (q_7)  [right=of q_6] {$(3, 1)$};
       \path[->]
        (q_0) edge[very thick]  node {} (q_5)
        (q_4) edge  node {} (q_1)
        (q_5) edge [bend left, out=40, in=140, below, very thick]  node {} (q_7)
        (q_6) edge   node {} (q_7)
        ;
    \end{tikzpicture}
    \caption{The Kronecker product graph of RSM $R$ and the input graph $\mathcal{G}$ (edges which form new paths are thick)}
    \label{fig:example_1_product}
\end{figure}
As far as the input graph has no edges with label $S$, the correspondent block of the Kronecker product will be empty. The Kronecker product graph of the input graph $\mathcal{G}$ and RSM $R$ is shown in Figure~\ref{fig:example_1_product}. Then, the transitive closure evaluation result, stored in the matrix $C_{3,(1)}$, introduces one new path of length 2 (the thick edges in Figure~\ref{fig:example_1_product}).

This path starts in the vertex $(0,0)$ and finishes in the vertex $(3,1)$.
We can see, that 0 and 3 are the start and final states of some component
state machine for label $S$ in $R$ respectively. Thus we can conclude that
there exists a path between vertices 0 and 1 in the graph, such that
respective word is derivable from $S$ in the $R$ execution flow.

As a result, we can add the edge $(0,S,1)$ to the result graph, what is
formally done by the update of the matrix $M_2^S$.

\textbf{Second iteration.} The modified graph Boolean adjacency matrices contain
an edge with label $S$. Therefore, this label contributes to the non-empty
corresponding matrix block in the evaluated matrix $M'_{3,{2}}$. The transitive closure
evaluation introduces three new paths $(0, 1) \rightarrow (2,1), (1, 0) \rightarrow (3,1)$ and $(0, 1) \rightarrow (3,1)$ (see Figure~\ref{fig:example_2_product}). Since only the path between vertices $(0,1)$ and
$(3,1)$ connects the start and final states in the automata, the edge $(1,S,1)$ is added
to the result graph.
{
    \renewcommand{\arraystretch}{0.5}
    \setlength\arraycolsep{0.1pt}
\begin{align*}
  \centering
& M'_{3,(2)} = M_1^a \otimes M_{2,(2)}^a +  M_1^b \otimes M_{2,(2)}^b + M_1^S \otimes M_{2,(2)}^S = \\
& \kbordermatrix{
          & (0,0) & (0,1) & \vrule & (1,0) & (1,1) & \vrule &  (2,0) & (2,1) & \vrule &  (3,0) & (3,1) &\\
    (0,0) & . & .  & \vrule & . & 1  & \vrule & . & .  &  \vrule & . & .  \\
    (0,1) & . & .  & \vrule & 1 & .   & \vrule & . & .  &  \vrule & . & .  \\
    \hline
    (1,0) & . & .   & \vrule & . & .  & \vrule & . & \mc  & \vrule & . & . \\
    (1,1) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & .  &1   \\
    \hline
    (2,0) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . & .  \\
    (2,1) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . &1  \\
    \hline
    (3,0) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . & .  \\
    (3,1) & . & .   & \vrule & . & .  & \vrule & . & .  & \vrule & . & .  \\
}
\end{align*}
}
\begin{figure}[h]
    \centering
   \begin{tikzpicture}[->,auto,node distance=0.5cm]
       \node[state] (q_0)                      {$(0, 0)$};
       \node[state] (q_1) [right=of q_0] {$(1, 0)$};
       \node[state] (q_2)  [right=of q_1] {$(2, 0)$};
       \node[state] (q_3) [right=of q_2] {$(3, 0)$};
       \node[state] (q_4)  [below=of q_0] {$(0, 1)$};
       \node[state] (q_5)  [right=of q_4] {$(1, 1)$};
      \node[state] (q_6)  [right=of q_5] {$(2, 1)$};
       \node[state] (q_7)  [right=of q_6] {$(3, 1)$};
       \path[->]
        (q_1) edge[very thick] node {} (q_6)
        (q_0) edge node {} (q_5)
        (q_4) edge[very thick]  node {} (q_1)
        (q_5) edge [bend left, in=140, out=40, below]  node {} (q_7)
        (q_6) edge[very thick]   node {} (q_7)
        ;
    \end{tikzpicture}
    \caption{The Kronecker product graph of RSM $R$ and the updated graph $\mathcal{G}$ (edges which form new paths are thick)}
    \label{fig:example_2_product}
\end{figure}
The result graph is presented in Figure~\ref{fig:example_result}.
\begin{figure}[h]
    \centering
    \begin{tikzpicture}[shorten >=1pt,auto]
       \node[state] (q_0)                      {$0$};
       \node[state] (q_1) [right=of q_0]       {$1$};
        \path[->]
        (q_0) edge[bend left, above]   node {a} (q_1)
         (q_0) edge[in=190, out=-10, red, very thick]   node {S} (q_1)
        (q_1) edge [bend left, below] node {a} (q_0)
         (q_1) edge[loop above, red, thick] node {S} (q_1)
        (q_1) edge[loop right] node {b} (q_1);

    \end{tikzpicture}
    \caption{The result graph $\mathcal{G}$}
    \label{fig:example_result}
\end{figure}


At this point the index creation is finished.
One can use it to answer reachability queries, but it also can be used
to restore paths for some reachable vertices. The result transitive closure matrix
$C_3$ or so called \textit{index} can be used for that. For example, let we try to
restore paths from 2 to 2 derived from $S$ in the result graph.

To get these paths we should call \verb|getPaths(1, 1, s)| function.
Partial trace of this call is presented below in Figure~\ref{trc:example}.
First, we must query paths for all possible start and final states of the
machine for the provided graph vertices. Since in the example RSM the component
state machine with label $S$ has a single final state, the function
\verb|getPathsInner| is called with arguments $(0,1)$ and $(3,1)$.
Note, that the values passed to the functions in the path extraction algorithm are the
pairs of the machine state and graph vertex, which uniquely identify a cell of
the index matrix $C_3$. Possible paths concatenation vertices are stored as \verb|parts={(1,0),(2,1)}|. Then we try to get parts of paths going through
index vertex $(1,0)$. All possible concatenations variants of the paths are
queried in the corresponding \verb|getSubpaths| function call. As the result,
we get the set of possible paths in the graph from $1$ to $1$.

\begin{figure}
\begin{minipage}[t]{0.48\textwidth}
{
\scriptsize
\setlength{\DTbaselineskip}{8pt}
\DTsetlength{0.2em}{0.5em}{0.2em}{0.4pt}{1.6pt}
\dirtree{%
.1 getPaths($1,1,S$).
.2 getPathsInner($(0,1),(3,1)$).
.3 parts$=\{(1,0),(2,1)\}$.
.3 getSubpaths($(0,1),(3,1),(1,0)$).
.4 l=$\{1 \xrightarrow{a} 0\}$.
.5 $\cdots$.
.6 getPathsInner($(0,0),(3,1)$).
.7 parts = $\{(1,1)\}$.
.8 ...
.9 getPaths($0,1,S$).
.10 ...
.11 getSubpaths($(0,0), (3,1), (1,1)$).
.12 $l=\{ 0 \xrightarrow{a} 1 \}$.
.12 $r=\{ 1 \xrightarrow{b} 1 \}$.
.12 return $\{ 0\xrightarrow{a} 1 \xrightarrow{b} 1 \}$.
.3 getSubpaths($(0,1), (3,1), (2,1)$).
.4 $\cdots$.
.5 getPaths(0, 1, S) // \begin{minipage}[t]{14cm} An alternative way to get paths from 0 to 1 (leads to infinite set of paths) \end{minipage}.
.5 ...
.10 return $r_\infty^{0 \leadsto 1}$ // \begin{minipage}[t]{5cm} An infinite set of path from 0 to 1 \end{minipage}.
.6 $\cdots$.
.2 return $\{1 \xrightarrow{a} 0 \xrightarrow{a} 1  \xrightarrow{b} 1 \xrightarrow{b} 1\} \cup (\{1 \xrightarrow{a}  0 \} \cdot r_\infty^{0\leadsto 1} \cdot \{1 \xrightarrow{b} 1\})$.
}
}
\caption{Example of call stack trace}
\label{trc:example}
\end{minipage}
\end{figure}

Lazy evaluation is required here, since the result graph may possibly have an
infinite number of path between some vertices pair. Another approach here is
to try to query some fixed number of paths, or just single path. Eventually,
the paths enumeration problem is actual here: how can we enumerate paths with small delay.