\section{About Libraries}

% Details on implementation. 
% Architecture.

% TODO:
% - stunning architecture diagram
% - exciting example of usage
% - unbelievable python API showcase 

Implemented sparse boolean linear algebra libraries for OpenCL and NVIDIA Cuda platforms are called
\textit{clBool}\footnote{clBool project: \url{https://replace/me/with/actual/url}} and \textit{cuBool}\footnote{cuBool project: \url{https://github.com/JetBrains-Research/cuBool}} respectively.
Projects are hosted at GitHub platform. The source code is licensed under MIT license.
The build process is configured with CMake tool. 
This process is straightforward and requires setup of only basic components and instruments, such as compiler, build configuration tools and platform-specific development kits.

Conceptual libraries architecture is depicted at figure~\ref{fig:generic_architecture}. 
The \textbf{Core} module itself is written in the C++ programming language, which is well-suited for performance and resource critical computational tasks. 
This module provides basic functionality, manages global state and answers user requests. 
The \textbf{Specifics} module provides actual operations and primitives implementation for concrete target execution platform.
Library exposes C compatible API, what gives expressiveness and allows to embed that API into other execution environments via interoperability mechanisms.
\textbf{Wrapper} modules generally encapsulates such functionality and provide it for target high-level runtimes, such as Python or .NET. 

Since library interface, core functionality and high-level wrappers stay the same for different platform specific implementations, it is convenient to create several Specifics modules for Cuda or OpenCL backends.
At this time clBool and cuBool have distinct infrastructures, but it can be integrated into single library with common interface and structure. 
This integration is something to be done in near future.
This process requires careful selection of the interface to allow the end user to properly configure the library for specific tasks, as well as the option to automatically select a specific implementation depending on the capabilities of the target device.

\begin{figure}[t]
    \centering
    % Todo: maybe draw this diagram more compact (vertically)
    \includegraphics[width=0.4\textwidth]{generic_architecture.png}
    \caption{Conceptual sparse boolean linear algebra library architecture}
    \label{fig:generic_architecture}
\end{figure}

Libraries operate on boolean semiring with values set \{\textit{true}, \textit{false}\} with \textit{false} as 
a neutral element, '+' operation defined as logical \textit{or} and '*' defined as logical \textit{and}. Values are also denoted as $\{1,~0\}$ respectively, and the abbreviation $\textit{NNZ(M)}$ gives the number of non-zero cells of the matrix $M$.

Main primitive is sparse matrix of boolean values, stored in one of the sparse formats. Sparse vector 
primitive is not presented, since its utilization is relatively rare presented in practical computational 
tasks. But its support is something to be added in far future. Primary available operations and functions are following.

\begin{itemize}
    \item Create sparse matrix $M$ of size $m \times n$.
    \item Delete sparse matrix $M$ and release all its internal resources.
    \item Fill the matrix $M$ with values $L = \{(i,j)_k\}_k$. The result of this operation is $M_{i,j} = 
    \textit{true}$ for each $(i, j) \in L$, and $M_{i,j} = \textit{false}$ for the rest of matrix values.
    \item Read matrix $M$ values $L = \{(i, j)~|~M_{i,j} = \textit{true}\}$.
    \item Matrix-matrix multiply-add operation $C \mathrel{+}= M \times N$.
    \item Matrix-matrix add operation $M \mathrel{+}= N$.
    \item Matrix-matrix Kronecker product $K = M \otimes N$.
\end{itemize}