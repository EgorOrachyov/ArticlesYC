\section{Introduction}

Language-constrained path querying~\cite{doi:10.1137/S0097539798337716}, and particularly context-free path querying (CFPQ)~\cite{Yannakakis}, allows one to express constraints for paths in a graph in terms of context-free grammars.
A path in a graph is included in a query result only if the labels along this path form a word that belongs to the language, generated by the query grammar.
CFPQ is widely used in bioinformatics~\cite{GraphQueryWithEarley}, graph databases querying~\cite{hellings2015querying,Medeiros:2018:EEC:3167132.3167265,10.1145/3335783.3335791}, and RDF analysis~\cite{RDF}.

CFPQ algorithms are actively developed but still suffer from poor performance~\cite{10.1145/3335783.3335791}.
The algorithm proposed by Rustam Azimov~\cite{Azimov:2018:CPQ:3210259.3210264} is one of the most promising.
This algorithm makes it possible to offload computational intensive parts to high-performance libraries for linear algebra, this way one can utilize modern parallel hardware for CFPQ.
One disadvantage of this algorithm is that a query grammar should be converted to a Chomsky Normal Form (CNF) which significantly increases its size.
The performance of the algorithm depends on the grammar size, thus it is desirable to create the algorithm which does not modify the query grammar.

In this work, we propose a new algorithm for CFPQ which can be expressed in terms of matrix operations and does not require grammar transformation.
This algorithm can be efficiently implemented on modern parallel hardware and it provides ways to optimize queries.
The main contribution of this paper could be summarized as follows.

\begin{enumerate}
\item We introduce a new algorithm for CFPQ, which is based on the intersection of recursive state machines and can be expressed in terms of Kronecker product and transitive closure.
\item We provide a step-by-step example of the algorithm.
\item We provide an evaluation of the presented algorithm and its comparison with the matrix-based algorithm.
The presented algorithm outperforms the previous matrix-based algorithm in the worst-case scenario, but further optimizations are required to make it applicable for real-world cases.
\end{enumerate}

